// Code generated by gowrap. DO NOT EDIT.
// template: methods.template
// gowrap: http://github.com/hexdigest/gowrap

package pool

//go:generate gowrap gen -p github.com/bloxapp/beacon-kit -i Client -t methods.template -o methods.go -l ""

import (
	"context"
	"sync"

	"github.com/attestantio/go-eth2-client/api"
	apiv1 "github.com/attestantio/go-eth2-client/api/v1"
	"github.com/attestantio/go-eth2-client/spec"
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	"github.com/bloxapp/beacon-kit"
)

type methods struct {
	defaultClient func() beacon.Client
	callFunc      func(ctx context.Context, callFunc func(context.Context, beacon.Client) error) error
}

type methodCtxKey struct{}

func methodFromContext(ctx context.Context) string {
	method, ok := ctx.Value(methodCtxKey{}).(string)
	if !ok {
		return "<unknown>"
	}
	return method
}

func (m *methods) Address() (s1 string) {
	return m.defaultClient().Address()
}

func (m *methods) AggregateAttestation(ctx context.Context, opts *api.AggregateAttestationOpts) (pp1 *api.Response[*phase0.Attestation], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AggregateAttestation")
	type _resultStruct struct {
		pp1 *api.Response[*phase0.Attestation]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.AggregateAttestation(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) AttestationData(ctx context.Context, opts *api.AttestationDataOpts) (pp1 *api.Response[*phase0.AttestationData], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AttestationData")
	type _resultStruct struct {
		pp1 *api.Response[*phase0.AttestationData]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.AttestationData(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) AttesterDuties(ctx context.Context, opts *api.AttesterDutiesOpts) (pp1 *api.Response[[]*apiv1.AttesterDuty], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AttesterDuties")
	type _resultStruct struct {
		pp1 *api.Response[[]*apiv1.AttesterDuty]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.AttesterDuties(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) BeaconBlockHeader(ctx context.Context, opts *api.BeaconBlockHeaderOpts) (pp1 *api.Response[*apiv1.BeaconBlockHeader], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BeaconBlockHeader")
	type _resultStruct struct {
		pp1 *api.Response[*apiv1.BeaconBlockHeader]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.BeaconBlockHeader(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) BeaconBlockRoot(ctx context.Context, opts *api.BeaconBlockRootOpts) (pp1 *api.Response[*phase0.Root], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BeaconBlockRoot")
	type _resultStruct struct {
		pp1 *api.Response[*phase0.Root]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.BeaconBlockRoot(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) Domain(ctx context.Context, domainType phase0.DomainType, epoch phase0.Epoch) (d1 phase0.Domain, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Domain")
	type _resultStruct struct {
		d1  phase0.Domain
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		d1, err := client.Domain(ctx, domainType, epoch)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{d1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.d1, _result.err
}

func (m *methods) Genesis(ctx context.Context, opts *api.GenesisOpts) (pp1 *api.Response[*apiv1.Genesis], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Genesis")
	type _resultStruct struct {
		pp1 *api.Response[*apiv1.Genesis]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.Genesis(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) GenesisDomain(ctx context.Context, domainType phase0.DomainType) (d1 phase0.Domain, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "GenesisDomain")
	type _resultStruct struct {
		d1  phase0.Domain
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		d1, err := client.GenesisDomain(ctx, domainType)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{d1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.d1, _result.err
}

func (m *methods) Name() (s1 string) {
	return m.defaultClient().Name()
}

func (m *methods) Proposal(ctx context.Context, opts *api.ProposalOpts) (pp1 *api.Response[*api.VersionedProposal], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Proposal")
	type _resultStruct struct {
		pp1 *api.Response[*api.VersionedProposal]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.Proposal(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) ProposerDuties(ctx context.Context, opts *api.ProposerDutiesOpts) (pp1 *api.Response[[]*apiv1.ProposerDuty], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "ProposerDuties")
	type _resultStruct struct {
		pp1 *api.Response[[]*apiv1.ProposerDuty]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.ProposerDuties(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) SignedBeaconBlock(ctx context.Context, opts *api.SignedBeaconBlockOpts) (pp1 *api.Response[*spec.VersionedSignedBeaconBlock], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SignedBeaconBlock")
	type _resultStruct struct {
		pp1 *api.Response[*spec.VersionedSignedBeaconBlock]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.SignedBeaconBlock(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) Spec(ctx context.Context, opts *api.SpecOpts) (pp1 *api.Response[map[string]any], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Spec")
	type _resultStruct struct {
		pp1 *api.Response[map[string]any]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.Spec(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) SubmitAggregateAttestations(ctx context.Context, aggregateAndProofs []*phase0.SignedAggregateAndProof) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitAggregateAttestations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitAggregateAttestations(ctx, aggregateAndProofs)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitAttestations(ctx context.Context, attestations []*phase0.Attestation) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitAttestations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitAttestations(ctx, attestations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitBeaconCommitteeSubscriptions(ctx context.Context, subscriptions []*apiv1.BeaconCommitteeSubscription) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitBeaconCommitteeSubscriptions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitBeaconCommitteeSubscriptions(ctx, subscriptions)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitBlindedProposal(ctx context.Context, opts *api.SubmitBlindedProposalOpts) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitBlindedProposal")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitBlindedProposal(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitProposal(ctx context.Context, opts *api.SubmitProposalOpts) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitProposal")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitProposal(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitProposalPreparations(ctx context.Context, preparations []*apiv1.ProposalPreparation) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitProposalPreparations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitProposalPreparations(ctx, preparations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeContributions(ctx context.Context, contributionAndProofs []*altair.SignedContributionAndProof) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeContributions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeContributions(ctx, contributionAndProofs)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeMessages(ctx context.Context, messages []*altair.SyncCommitteeMessage) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeMessages")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeMessages(ctx, messages)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeSubscriptions(ctx context.Context, subscriptions []*apiv1.SyncCommitteeSubscription) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeSubscriptions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeSubscriptions(ctx, subscriptions)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitValidatorRegistrations(ctx context.Context, registrations []*api.VersionedSignedValidatorRegistration) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitValidatorRegistrations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitValidatorRegistrations(ctx, registrations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SyncCommitteeContribution(ctx context.Context, opts *api.SyncCommitteeContributionOpts) (pp1 *api.Response[*altair.SyncCommitteeContribution], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SyncCommitteeContribution")
	type _resultStruct struct {
		pp1 *api.Response[*altair.SyncCommitteeContribution]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.SyncCommitteeContribution(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) SyncCommitteeDuties(ctx context.Context, opts *api.SyncCommitteeDutiesOpts) (pp1 *api.Response[[]*apiv1.SyncCommitteeDuty], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SyncCommitteeDuties")
	type _resultStruct struct {
		pp1 *api.Response[[]*apiv1.SyncCommitteeDuty]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.SyncCommitteeDuties(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}

func (m *methods) Validators(ctx context.Context, opts *api.ValidatorsOpts) (pp1 *api.Response[map[phase0.ValidatorIndex]*apiv1.Validator], err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Validators")
	type _resultStruct struct {
		pp1 *api.Response[map[phase0.ValidatorIndex]*apiv1.Validator]
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		pp1, err := client.Validators(ctx, opts)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{pp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.pp1, _result.err
}
